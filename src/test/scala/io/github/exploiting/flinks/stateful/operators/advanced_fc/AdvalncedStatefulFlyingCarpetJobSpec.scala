package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.BaseSpec
import io.github.exploiting.flinks.stateful.operators.model.SimpleTransaction
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment
import org.apache.flink.streaming.api.scala._
import org.apache.flink.contrib.streaming.DataStreamUtils
import org.apache.flink.streaming.api.functions.sink.SinkFunction
import org.apache.flink.util.Collector

import scala.collection.JavaConverters.asScalaIteratorConverter
import scala.collection.mutable.ListBuffer


class AdvalncedStatefulFlyingCarpetJobSpec extends BaseSpec {

  "Advanced Flying Carpet Job" should {
    "enrich simple event correctly" in {

      val env = StreamExecutionEnvironment.createLocalEnvironment()
      env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

      val startTime = 1488070307638L

      val inputData = List(
        SimpleTransaction("Olga", 123, (10.0, 10.0), startTime + 1000, 100.0),
        SimpleTransaction("Olga", 123, (10.0, 10.0), startTime + 1010, 50.0)
      )

      val inputStream = env.fromElements(inputData: _*)

      val resultStream: DataStream[EnrichedTransaction] = AdvancedStatefulFlyingCarpetJob.createJob(inputStream)

      resultStream.addSink(TestCollectionSink[EnrichedTransaction]())
      env.execute("AdvalncedStatefulFlyingCarpetJobSpec")

      val collectedResult = TestSinkCollector.collectedData

      println(s"=======================\n")
      collectedResult.foreach(println)
    }
  }

}

case class TestCollectionSink[T]() extends SinkFunction[T] {

  override def invoke(in: T): Unit = TestSinkCollector.collectData(in)

}

/** this has to be an object, because if it is a class, flink will create a new object of this class
  * and we wont be able to access the collected items anymore
  * NOTE: we must clean the collected list before each test*/
case object TestSinkCollector {
  private var listData: List[Any] = List.empty

  def collectedData: List[Any] = listData

  def collectData(in: Any): Unit = {
    listData = listData :+ in
  }

  def reset(): Unit = {
    listData = List.empty
  }
}