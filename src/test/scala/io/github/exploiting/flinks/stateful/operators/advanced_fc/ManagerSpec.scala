package io.github.exploiting.flinks.stateful.operators.advanced_fc

import cats.{Id, ~>}
import io.github.exploiting.flinks.stateful.operators.model.UTCLocation
import org.scalatest.{Matchers, WordSpec}

import scala.collection.mutable

class ManagerSpec extends WordSpec with Matchers {

  "Manager" should {

    "return keyedOperations for both keys" in {
      val key1 = "cardId"
      val key2 = "customerId"
      val cardIdResult = Manager.keyedOperations(key1)
      val customerIdResult = Manager.keyedOperations(key2)

      cardIdResult._1 shouldBe List("amount")
      customerIdResult._1 shouldBe List("UTC", "location")
    }

    "define averageAmount with value" in {
      val key: List[(Key, Value)] = List("key" -> "value")
      val input = mutable.Map(key -> (1 -> 100.0))
      val interpreter = TestAmountInterpreter(input)

      val sut: StateF[Double] = Manager.averageAmount(key, Tuple1(10.0))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain only (key -> (2, 110.0))
      result shouldBe 100.0
    }

    "define averageAmount with multiple values" in {
      val key: List[(Key, Value)] = List("key" -> "value")
      val input = mutable.Map(key -> (4 -> 100.0))
      val interpreter = TestAmountInterpreter(input)

      val sut: StateF[Double] = Manager.averageAmount(key, Tuple1(10.0))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain only (key -> (5, 110.0))
      result shouldBe 25.0
    }

    "keyedDefinitions" in {
      val expected = List("customerId", "cardId")
      val result = Manager.keyedDefinitions
      result shouldBe expected
    }

    "speedDerivation when value is already is present" in {
      val key: List[(Key, Value)] = List("key" -> "value")
      val input = mutable.Map(key -> (0L, (0.0, 0.0)))
      val interpreter = TestSpeedInterpreter(input)

      val sut: StateF[Double] = Manager.speedDerivation(key, (3600000L, (10.0, 10.0)))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain only (key -> (3600000L, (10.0, 10.0)))
      result shouldBe (1568.52 +- 0.01)
    }

    "speedDerivation when no initial value is present" in {
      val key: List[(Key, Value)] = List("key" -> "value")
      val input = mutable.Map.empty[List[(Key, Value)], (Long, (Double, Double))]
      val interpreter = TestSpeedInterpreter(input)

      val sut: StateF[Double] = Manager.speedDerivation(key, (3600000L, (10.0, 10.0)))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain (key -> (3600000L, (10.0, 10.0)))
      result shouldBe Double.NaN
    }

    "speedDerivation when multiple keys and values are present" in {
      val key: List[(Key, Value)] = List("key" -> "value")
      val key2: List[(Key, Value)] = List("key2" -> "value2")
      val input = mutable.Map(key -> (0L, (0.0, 0.0)), key2 -> (100L, (100.0, 100.0)))
      val interpreter = TestSpeedInterpreter(input)

      val sut: StateF[Double] = Manager.speedDerivation(key, (3600000L, (10.0, 10.0)))

      val result = sut.foldMap(interpreter)

      interpreter.state.size shouldBe 2
      interpreter.state should contain (key -> (3600000L, (10.0, 10.0)))
      result shouldBe (1568.52 +- 0.01)
    }

  }
}

case class TestSpeedInterpreter(state: mutable.Map[List[(Key, Value)], UTCLocation]) extends (State ~> Id) {
  //var state: Map[List[(Key, Value)], Value] = init.getOrElse(Map.empty)
  override def apply[A](fa: State[A]): Id[A] = fa match {
    case Put(key, value) =>
      println(s"value: $value added to key: $key")
      state += (key -> value.asInstanceOf[UTCLocation])
      println(s"state is now: $state")
      ()
    case Get(key) =>
      println(s"getting value for key: $key")
      val result = state.get(key)
      println(s"value is: $result")
      result
    case Delete(key) =>
      state.remove(key)
      ()
  }
}

case class TestAmountInterpreter(state: mutable.Map[List[(Key, Value)], (Int, Double)]) extends (State ~> Id) {
  //var state: Map[List[(Key, Value)], Value] = init.getOrElse(Map.empty)
  override def apply[A](fa: State[A]): Id[A] = fa match {
    case Put(key, value) =>
      println(s"value: $value added to key: $key")
      state += (key -> value.asInstanceOf[(Int, Double)])
      println(s"state is now: $state")
      ()
    case Get(key) =>
      println(s"getting value for key: $key")
      val result = state.get(key)
      println(s"value is: $result")
      result
    case Delete(key) =>
      state.remove(key)
      ()
  }
}

