package io.github.exploiting.flinks.stateful.operators.advanced_fc

import cats.{Id, ~>}
import io.github.exploiting.flinks.stateful.operators.model.{SimpleTransaction, UTCLocation}
import org.scalatest.{Matchers, WordSpec}

import scala.collection.mutable

class ManagerSpec extends WordSpec with Matchers {

  "Manager" should {

    "return keyedOperations for both keys" in {
      val key1 = List("cardId")
      val key2 = List("customerId")
      val cardIdResult = Manager.featureForKey(key1)
      val customerIdResult = Manager.featureForKey(key2)

      cardIdResult.featureName shouldBe "averageAmount"
      customerIdResult.featureName shouldBe "utcLocation"
    }

    "define averageAmount with value" in {
      val key = "averageAmount"
      val input = mutable.Map(key -> (1 -> 100.0))
      val interpreter = TestInterpreter[(Int, Double)](input)

      val sut: StateF[Double] = Manager.averageAmount(key, Tuple1(10.0))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain only (key -> (2, 110.0))
      result shouldBe 100.0
    }

    "define averageAmount with multiple values" in {
      val key = "averageAmount"
      val input = mutable.Map(key -> (4 -> 100.0))
      val interpreter = TestInterpreter[(Int, Double)](input)

      val sut: StateF[Double] = Manager.averageAmount(key, Tuple1(10.0))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain only (key -> (5, 110.0))
      result shouldBe 25.0
    }

    "keyedDefinitions" in {
      val expected = List(List("customerId"), List("cardId"))
      val result = Manager.definedKeys
      result shouldBe expected
    }

    "speedDerivation when value is already is present" in {
      val key = "utcLocation"
      val input = mutable.Map(key -> (0L, (0.0, 0.0)))
      val interpreter = TestInterpreter[UTCLocation](input)

      val sut: StateF[Double] = Manager.speedDerivation(key, (3600000L, (10.0, 10.0)))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain only (key -> (3600000L, (10.0, 10.0)))
      result shouldBe (1568.52 +- 0.01)
    }

    "speedDerivation when no initial value is present" in {
      val key = "utcLocation"
      val input = mutable.Map.empty[String, (Long, (Double, Double))]
      val interpreter = TestInterpreter[UTCLocation](input)

      val sut: StateF[Double] = Manager.speedDerivation(key, (3600000L, (10.0, 10.0)))

      val result = sut.foldMap(interpreter)

      interpreter.state should contain(key -> (3600000L, (10.0, 10.0)))
      assert(result.isNaN)
    }

    "speedDerivation when multiple keys and values are present" in {
      val key = "key"
      val key2 = "key2"
      val input = mutable.Map(key -> (0L, (0.0, 0.0)), key2 -> (100L, (100.0, 100.0)))
      val interpreter = TestInterpreter[UTCLocation](input)

      val sut: StateF[Double] = Manager.speedDerivation(key, (3600000L, (10.0, 10.0)))

      val result = sut.foldMap(interpreter)

      interpreter.state.size shouldBe 2
      interpreter.state should contain(key -> (3600000L, (10.0, 10.0)))
      result shouldBe (1568.52 +- 0.01)
    }

  }
}

case class TestInterpreter[T](state: mutable.Map[String, T]) extends (State ~> Id) {
  //var state: Map[List[(Key, Value)], Value] = init.getOrElse(Map.empty)
  override def apply[A](fa: State[A]): Id[A] = fa match {
    case Put(key, value) =>
      println(s"value: $value added to key: $key")
      state += (key -> value.asInstanceOf[T])
      println(s"state is now: $state")
      ()
    case Get(key) =>
      println(s"getting value for key: $key")
      val result = state.get(key)
      println(s"value is: $result")
      result
    case Delete(key) =>
      state.remove(key)
      ()
  }
}

