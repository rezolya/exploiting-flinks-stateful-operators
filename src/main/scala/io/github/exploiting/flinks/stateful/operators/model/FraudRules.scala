package io.github.exploiting.flinks.stateful.operators.model

import io.github.exploiting.flinks.stateful.operators.advanced_fc.EnrichedTransaction

object FraudRules {

  def inputIsFraudulent[Event](detector: Event => Boolean)(in: Event): Boolean =
    detector(in)
// TODO: get rid of structural typing.
  def scoreFlyingCarpet(input: { val customerSpeed: Double }): Boolean =
    input.customerSpeed > 1000.0

  // TODO: get rid of structural typing.
  def scoreImprovedFlyingCarpet(input: { val customerSpeed: Double; val avCardTransactionAmount: Double; val transaction: SimpleTransaction }): Boolean =
    input.customerSpeed > 1000.0 && ((input.avCardTransactionAmount - input.transaction.amount)>(2*input.avCardTransactionAmount))

  // TODO make it strongly typed?
  def scoreAdvancedFlyingCarpet(input: EnrichedTransaction): Boolean =
    input.state("customerId").asInstanceOf[Double] > 1000.0 &&
      ((input.state("cardId").asInstanceOf[Double] - input.payload("amount").asInstanceOf[Double])>(2*input.state("cardId").asInstanceOf[Double]))

  def deriveSpeed(currentLocation: Location, currentUTC: Long, prevLocation: Location, prevUTC: Long): Double ={
    val distance = calculateDistance(currentLocation, prevLocation) //distance in km
    val time = millisToHours(currentUTC - prevUTC)
    distance/time
  }

  def standardDeviation(list: Seq[Int]): Double =
    if (list.length > 2) Math.sqrt(list.sum / (list.length - 1)) else 0.0

  def mean(list: Seq[Int]): Double =
    if (list.nonEmpty) list.sum / list.length else 0.0

  def twiceStdDevPredicate(history: Seq[Int]): Int => Boolean = in =>
    in > mean(history) + (2 * standardDeviation(history)) ||
    in < mean(history) - (2 * standardDeviation(history))

  /**
    *  Calculates the distance in km between two coordinates using the "haversine" formula
    *  to calculate the great-circle distance between two points – that is,
    *  the shortest distance over the earth’s surface – giving an ‘as-the-crow-flies’ distance between the points
    */
  def calculateDistance(p1: Location, p2: Location): Double = {
    val earthRadius = 6371; // in km

    val (lat1, lon1) = p1
    val (lat2, lon2) = p2

    var dLat = Math.toRadians(lat1 - lat2)
    var dLon = Math.toRadians(lon1 - lon2)

    var a =  Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLon/2)*Math.sin(dLon/2)
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

    earthRadius * c; // Distance in km

  }

  def millisToHours(millis: Long): Double = millis / 1000 / 3600
}
