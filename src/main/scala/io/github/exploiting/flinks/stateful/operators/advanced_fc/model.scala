package io.github.exploiting.flinks.stateful.operators.advanced_fc

import java.util.UUID

import io.github.exploiting.flinks.stateful.operators.model.{SimpleTransaction, TransactionEvent}

case class UuidTransaction(id: UUID, payload: Map[String, Any]) extends TransactionEvent

case class DynamicKeyEvent(id: UUID, key: KeyWithValues, payload: Map[String, Any], operation: List[String])

case class DynamicState(state: Map[String, Any]){
  def update( newValues: List[(String, Any)]): DynamicState = DynamicState(state ++ newValues)
}

case class EnrichedTransaction(id: UUID, payload: Map[String, Any], state: Map[String, Any])

case class EnrichedSimpleTransaction(id: UUID,
                                     transaction: Option[SimpleTransaction],
                                     customerSpeed: Double,
                                     avCardTransactionAmount: Double) extends TransactionEvent

case class UuidWithState(id: UUID,
                         key: KeyWithValues, // we need to know to which key this state belongs to, in case we want to aggregate the same payload with different keys (f.e. total amount per card and total amount per customer)
                         state: Map[String, Any]) extends TransactionEvent

case class CardState(totalAmount: Double, totalNrTransactions: Int)

import cats.{Id, ~>}
import cats.free.Free
import cats.free.Free.liftF

sealed trait State[A]
case class Put[T](key: List[(Key, Value)], value: T) extends State[Unit]
case class Get[T](key: List[(Key, Value)]) extends State[Option[T]]
case class Delete(key: List[(Key, Value)]) extends State[Unit]

object State {


  // Free is implemented (since https://github.com/typelevel/cats/commit/8618077fdd5e468ebe5b69f081a87fada49f34b1)
  // that it can take any type constructor, instead of only Functors, (Yoneda lemma).

  // Put returns nothing (i.e. Unit).
  def put[T](key: List[(Key, Value)], value: T): StateF[Unit] =
    liftF[State, Unit](Put[T](key, value))

  // Get returns a T value.
  def get[T](key: List[(Key, Value)]): StateF[Option[T]] =
    liftF[State, Option[T]](Get[T](key))

  // Delete returns nothing (i.e. Unit).
  def delete(key: List[(Key, Value)]): StateF[Unit] =
    liftF(Delete(key))

  // Update composes get and set, and returns nothing.
  def update[T](key: List[(Key, Value)], f: T => T): StateF[Unit] =
    for {
      vMaybe <- get[T](key)
      _ <- vMaybe.map(v => put[T](key, f(v))).getOrElse(Free.pure(()))
    } yield ()

  // Update composes get and set, and sets default value if nothing is present.
  def updateWithDefault[T](key: List[(Key, Value)], f: T => T, default: T): StateF[Unit] =
    for {
      vMaybe <- get[T](key)
      _ <- vMaybe.map(v => put[T](key, f(v))).getOrElse(put[T](key, default))
    } yield ()

}

case class FlinkInterpreter(private val init: Option[Map[List[(Key, Value)], Value]]) extends (State ~> Id) {
  var state: Map[List[(Key, Value)], Value] = init.getOrElse(Map.empty)
  override def apply[A](fa: State[A]): Id[A] = fa match {
    case Put(key, value) =>
      println(s"value: $value added to key: $key")
      state = state + (key -> value)
      println(s"state is now: $state")
      ()
    case Get(key) =>
      println(s"getting value for key: $key")
      val result = state.get(key)
      println(s"value is: $result")
      result
    case Delete(key) =>
      state = state.filterKeys(_ != key)
      ()
  }
}
