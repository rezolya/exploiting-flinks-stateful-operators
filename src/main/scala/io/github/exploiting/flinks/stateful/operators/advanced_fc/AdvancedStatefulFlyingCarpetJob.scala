package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.magic.Mappable._
import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import org.apache.flink.api.common.state.{ValueState, ValueStateDescriptor}
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.functions.co.RichCoFlatMapFunction
import org.apache.flink.streaming.api.scala._
import org.apache.flink.util.Collector

object AdvancedStatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 1)

  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)
    val result: DataStream[ScoringResult] = createJob(inputStream)

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Advanced-keyed Fraudulent Transaction")
  }

  def createJob(inputStream: DataStream[SimpleTransaction]): DataStream[ScoringResult] = {
    // Give unique Id to incoming event for joining later in the chain.
    val uuidStream: DataStream[UuidTransaction] = inputStream.map { simpleTransaction =>
      println(s"simpleTransaction = $simpleTransaction")
      val numberOfKeys = Manager.keyedDefinitions(simpleTransaction).size
      // This is converted to Map[String, Any] because 'we cannot know beforehand what types are coming in'.
      UuidTransaction(java.util.UUID.randomUUID, numberOfKeys, simpleTransaction.toMap)
    }

    // Determine which operations we need to perform on each 'node'.
    val customKeyStream: DataStream[DynamicKeyEvent] = uuidStream
      .flatMap[DynamicKeyEvent](
        (ust: UuidTransaction, coll: Collector[DynamicKeyEvent]) =>
        Manager.keyedDefinitions(ust).foreach { key =>
          val (keyName, keySelector, keyOperation) = Manager.keyedOperations(key)

          coll.collect (
            // `key take-away` the key is a composition of keyname and value of that key.
            // By doing this we can ensure that the 'following' events will end up at the same node.
            // TODO: get key dynamically and not hardcoded List.
            DynamicKeyEvent(ust.id, keyName, List((key, ust.payload(key))), ust.payload, (keySelector, keyOperation))
          )
        }
    )

    // Perform operation at the node where the key belongs.
    val stateStream: DataStream[ResultEvent] = customKeyStream
      .keyBy(dynamicKey => dynamicKey.keyWithValues)
      .mapWithState[ResultEvent, Map[String, Value]] {
        case (event: DynamicKeyEvent, maybeState: Option[Map[String, Value]]) =>
          // assign the `program` we want to execute on the 'Value'.
          val ops: (String, Value) => StateF[Double] = event.operation._2

          // extract all needed values from the payload
          val constructedValue: Seq[Value] = event.operation._1.map(event.payload(_))

          import io.github.exploiting.flinks.stateful.operators.magic.ToTuple._
          val tup = constructedValue.toTuple

          // Initialize the interpreter that will be executing our `program`
          val interpreter = FlinkInterpreter(maybeState)

          // Execute the program, return type for now is Double, but could be Any.
          val result: Double = ops(event.keyName, tup).foldMap(interpreter)

          // Return the result, and assign the new state to this operator.
          (ResultEvent(event.id, event.keyName, result), Some(interpreter.state))
    }

    // Join the original event with the picked up state based on UUID.
    val enrichedStream: DataStream[EnrichedTransaction] = uuidStream
      .keyBy(uuidTransaction => uuidTransaction.id)
      .connect(stateStream.keyBy(results => results.id))
      .flatMap(new JoinStreams)

    //now we can score the improved model
    val result = enrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreAdvancedFlyingCarpet(event))
    )

    result
  }

  def waitForResults(event: TransactionEvent): Long =
    Manager.keyedDefinitions(event).length

}

class JoinStreams extends RichCoFlatMapFunction[UuidTransaction, ResultEvent, EnrichedTransaction] {
  private var resultEvents: ValueState[Map[String, Any]] = _
  private var enrichedEvent: ValueState[Seq[EnrichedTransaction]] = _

  override def open(config: Configuration): Unit = {
    super.open(config)
    val resultEventDesc: ValueStateDescriptor[Map[String, Any]] = new ValueStateDescriptor("resultEvents", classOf[Map[String, Any]])
    resultEvents = getRuntimeContext.getState(resultEventDesc)

    val uuidDesc: ValueStateDescriptor[Seq[EnrichedTransaction]] = new ValueStateDescriptor("enrichedEvent", classOf[Seq[EnrichedTransaction]])
    enrichedEvent = getRuntimeContext.getState(uuidDesc)
  }

  /**
    * What do we do, when an UUIDtransaction comes in?
    * First, check if there are already resultevents, (are we complete? => collect) otherwise update state and continue.
    * @param value
    * @param out
    */
  override def flatMap1(value: UuidTransaction, out: Collector[EnrichedTransaction]): Unit = {
    val expectedResults = Manager.keyedDefinitions(value).size

    val results = Option(resultEvents.value()).getOrElse(Map.empty)

    if (results.size == expectedResults) {
      // We're complete, collect.
      out.collect(EnrichedTransaction(value.id, value.payload, results))
      resultEvents.clear()
      enrichedEvent.clear()
    }
    else {
      enrichedEvent.update(Seq(EnrichedTransaction(value.id, value.payload, results)))
    }
  }

  override def flatMap2(value: ResultEvent, out: Collector[EnrichedTransaction]): Unit = {
    // Get the uuidevetn from state.
    val results: Seq[EnrichedTransaction] = Option(enrichedEvent.value()).getOrElse(Seq())
    // append the new element to the results.
    val newState: Map[String, Any] = Option(resultEvents.value()).getOrElse(Map.empty) + (value.key -> value.result)

    if (results.nonEmpty) {
      // TODO make dynamic.
      val expectedResults = 2

      if (newState.size == expectedResults) {
        out.collect(results.head.copy(state = newState))

        resultEvents.clear()
        enrichedEvent.clear()
      }
      else {
        // we're not complete yet. update state.
        resultEvents.update(newState)
      }
    }
    else {
      // we don't have the uuidevent yet.
      resultEvents.update(newState)
    }
  }
}
