package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.magic.Mappable._
import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import org.apache.flink.api.common.state._
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.functions.co.RichCoFlatMapFunction
import org.apache.flink.streaming.api.scala._
import org.apache.flink.util.Collector

object AdvancedStatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 1)

  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)
    val result: DataStream[ScoringResult] = createJob(inputStream)

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Advanced-keyed Fraudulent Transaction")
  }

  def createJob(inputStream: DataStream[SimpleTransaction]): DataStream[ScoringResult] = {
    // Give unique Id to incoming event for joining later in the chain.
    val uuidStream: DataStream[UuidTransaction] = inputStream.map { simpleTransaction =>
      println(s"simpleTransaction = $simpleTransaction")
      val numberOfKeys = Manager.keyedDefinitions(simpleTransaction).size
      // This is converted to Map[String, Any] because 'we cannot know beforehand what types are coming in'.
      UuidTransaction(java.util.UUID.randomUUID, numberOfKeys, simpleTransaction.toMap)
    }

    // Determine which operations we need to perform on each 'node'.
    val customKeyStream: DataStream[DynamicKeyEvent] = uuidStream
      .flatMap[DynamicKeyEvent](
        (ust: UuidTransaction, coll: Collector[DynamicKeyEvent]) =>
        Manager.keyedDefinitions(ust).foreach { key =>
          val (keyName, keySelector, keyOperation) = Manager.keyedOperations(key)

          coll.collect (
            // `key take-away` the key is a composition of keyname and value of that key.
            // By doing this we can ensure that the 'following' events will end up at the same node.
            // TODO: get key dynamically and not hardcoded List.
            DynamicKeyEvent(ust.id, keyName, List((key, ust.payload(key))), ust.splitUp, ust.payload, (keySelector, keyOperation))
          )
        }
    )

    // Perform operation at the node where the key belongs.
    val stateStream: DataStream[ResultEvent] = customKeyStream
      .keyBy(dynamicKey => dynamicKey.keyWithValues)
      .mapWithState[ResultEvent, Map[String, Value]] {
        case (event: DynamicKeyEvent, maybeState: Option[Map[String, Value]]) =>
          // assign the `program` we want to execute on the 'Value'.
          val ops: (String, Value) => StateF[Double] = event.operation._2

          // extract all needed values from the payload
          val constructedValue: Seq[Value] = event.operation._1.map(event.payload(_))

          import io.github.exploiting.flinks.stateful.operators.magic.ToTuple._
          val tup = constructedValue.toTuple

          // Initialize the interpreter that will be executing our `program`
          val interpreter = FlinkInterpreter(maybeState)

          // Execute the program, return type for now is Double, but could be Any.
          val result: Double = ops(event.keyName, tup).foldMap(interpreter)

          // Return the result, and assign the new state to this operator.
          (ResultEvent(event.id, event.keyName, result, event.expectedAmount), Some(interpreter.state))
    }

    // Join the original event with the picked up state based on UUID.
    val enrichedStream: DataStream[EnrichedTransaction] = uuidStream
      .keyBy(uuidTransaction => uuidTransaction.id)
      .connect(stateStream.keyBy(results => results.id))
      .flatMap(new JoinStreams)

    //now we can score the improved model
    val result = enrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreAdvancedFlyingCarpet(event))
    )

    result
  }

  def waitForResults(event: TransactionEvent): Long =
    Manager.keyedDefinitions(event).length

}

class JoinStreams extends RichCoFlatMapFunction[UuidTransaction, ResultEvent, EnrichedTransaction] {
  import scala.collection.JavaConverters._

  private var resultEvents: MapState[String, Any] = _
  private var enrichedEvent: ListState[UuidTransaction] = _

  private def resultEventsAsScalaMap: Predef.Map[String, Any] = Option(resultEvents.entries()).fold(Predef.Map.empty[String, Any])(_.iterator().asScala.toList.map(entry => entry.getKey -> entry.getValue).toMap)
  private def numberOfResultEvents: Int = resultEvents.keys().asScala.size
  private def enrichedEventsAsScalaIterable: Iterable[UuidTransaction] = enrichedEvent.get.asScala
  private def numberOfEnrichedEvents: Int = enrichedEvent.get.asScala.size

  override def open(config: Configuration): Unit = {
    super.open(config)
    val resultEventDesc: MapStateDescriptor[String, Any] = new MapStateDescriptor("resultEvents", classOf[String], classOf[Any])
    resultEvents = getRuntimeContext.getMapState(resultEventDesc)

    val uuidDesc: ListStateDescriptor[UuidTransaction] = new ListStateDescriptor("uuidDescriptor", classOf[UuidTransaction])
    enrichedEvent = getRuntimeContext.getListState(uuidDesc)
  }

  /**
    * What do we do, when an UUIDtransaction comes in?
    * First, check if there are already resultevents, (are we complete? => collect) otherwise update state and continue.
    * @param value
    * @param out
    */
  override def flatMap1(value: UuidTransaction, out: Collector[EnrichedTransaction]): Unit = {
    val expectedResults = value.splitUp

    if (numberOfResultEvents == expectedResults) {
      // We're complete, collect.
      out.collect(EnrichedTransaction(value.id, value.payload, resultEventsAsScalaMap))
      resultEvents.clear()
      enrichedEvent.clear()
    }
    else {
      enrichedEvent.add(value)
    }
  }

  override def flatMap2(value: ResultEvent, out: Collector[EnrichedTransaction]): Unit = {

    if (numberOfEnrichedEvents > 0) {
      val expectedResults = value.expectedAmount

      if (numberOfResultEvents +1 == expectedResults) {
        val uuidTransactionFromState = enrichedEventsAsScalaIterable.head
        // append the new element to the results.
        out.collect(
          EnrichedTransaction(uuidTransactionFromState.id,
            uuidTransactionFromState.payload,
            resultEventsAsScalaMap + (value.key -> value.result))
        )

        resultEvents.clear()
        enrichedEvent.clear()
      }
      else {
        // we're not complete yet. update state.
        resultEvents.put(value.key, value.result)
      }
    }
    else {
      // we don't have the uuidevent yet.
      resultEvents.put(value.key, value.result)
    }
  }
}
