package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.advanced_fc.Manager._
import io.github.exploiting.flinks.stateful.operators.magic.ConvertHelper
import io.github.exploiting.flinks.stateful.operators.magic.Mappable._
import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment, _}
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows
import org.apache.flink.streaming.api.windowing.time.Time

import scala.collection.immutable

object AdvancedStatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)

    // Give unique Id to incoming event for joining later in the chain.
    val uuidStream: DataStream[UuidSimpleTransaction] = inputStream.map {
      s => UuidSimpleTransaction(java.util.UUID.randomUUID, s.toMap)
    }.keyBy(inputStream => inputStream.id)

    val customKeyStream: DataStream[DynamicKeyEvent] = uuidStream
      .flatMap[DynamicKeyEvent]((ust, coll) =>
        Manager.keyedDefinitions.foreach(key =>
          coll.collect(DynamicKeyEvent(ust.id, List((key, ust.payload(key))), ust.payload, (Manager.keyedOperations(key))))))

    val stateStream = customKeyStream
      .keyBy(dynamicKeyEvent => dynamicKeyEvent.key)
      .flatMapWithState[DynamicKeyEvent, Map[List[(Key, Value)], Value]] {
        case (event: DynamicKeyEvent, maybeState: Option[Map[List[(Key, Value)], Value]]) =>
          val evaluateOps: List[Any] = event.operation.map(op => event.payload(op))
          val newState = maybeState match {
            case None => Map(event.key -> evaluateOps)
            case Some(state) => state.getOrElse(event.key, evaluateOps) //FraudRules.deriveSpeed(transaction.location, transaction.UTC, state.prevLocation, state.prevUTC)
          }
          val enriched = EnrichedSimpleTransaction(event.id, event.payload.to[SimpleTransaction], speed, 0)
          (enriched, Some(newState))
      }

    // Store the current card total amount and number of transaction and calculate the average transaction amount
    val keyedByCardStream: DataStream[EnrichedSimpleTransaction] = inputStream
      .keyBy(transaction => transaction.cardId)
      .mapWithState[EnrichedSimpleTransaction, CardState]{
        case (transaction, maybeState: Option[CardState]) =>
        val prevState = maybeState.getOrElse(CardState(0, 0))
        val newState =  CardState(prevState.totalAmount+transaction.amount, prevState.totalNrTransactions+1)
        val avTransactionAmount = if(prevState.totalNrTransactions>0) prevState.totalAmount/prevState.totalNrTransactions else 0

        val enriched = EnrichedSimpleTransaction(transaction, 0, avTransactionAmount)
        (enriched, Some(newState))
      }

    // Join the customerResult and cardResult based on cardId.
    val enrichedStream = uuidStream.join(stateStream)
      .where(_.id)
      .equalTo(_.id)
      .window(TumblingEventTimeWindows.of(Time.milliseconds(100))) //we wait 100 millis before discarding the event).
      .apply { (customerEnrichedTransaction, cardEnrichedTransaction) =>
        EnrichedSimpleTransaction(customerEnrichedTransaction.transaction, customerEnrichedTransaction.customerSpeed, cardEnrichedTransaction.avCardTransactionAmount)
      }

    //now we can score the improved model
    val result = enrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreFlyingCarpet(event))
    )

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Advanced-keyed Fraudulent Transaction")
  }

  // Convert back to case class. 
  def to[A]: ConvertHelper[A] = new ConvertHelper[A]

}


/**
  * History class that is a circular buffer, oldest elements are overwritten when the buffer is full.
  * @param maxSize How many items we want to store.
  * @param buffer Initialize it with a buffer.
  * @tparam A The type we store in this class.
  */
case class History[A](maxSize: Int, buffer: Vector[A] = immutable.Vector.empty[A]) {
  type CircularBuffer = immutable.Vector[A]

  private def addToCircularBuffer(item : A) : CircularBuffer  =
    if(maxSize > 0)
      buffer.drop(buffer.size - maxSize + 1) :+ item
    else
      buffer

  def :+(item: A): History[A] = History(maxSize, addToCircularBuffer(item))
}
