package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.magic.Mappable._
import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import org.apache.flink.api.common.state._
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.functions.co.RichCoFlatMapFunction
import org.apache.flink.streaming.api.scala._
import org.apache.flink.util.Collector

object AdvancedStatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 1)

  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)
    val result: DataStream[ScoringResult] = createJob(inputStream)

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Advanced-keyed Fraudulent Transaction")
  }

  def createJob(inputStream: DataStream[SimpleTransaction]): DataStream[ScoringResult] = {
    // Give unique Id to incoming event for joining later in the chain.
    val uuidStream: DataStream[UuidTransaction] = inputStream.map { simpleTransaction =>
      println(s"simpleTransaction = $simpleTransaction")
      val numberOfKeys = Manager.keyedDefinitions(simpleTransaction).size
      // This is converted to Map[String, Any] because 'we cannot know beforehand what types are coming in'.
      UuidTransaction(java.util.UUID.randomUUID, numberOfKeys, simpleTransaction.toMap)
    }

    // Determine which operations we need to perform on each 'node'.
    val customKeyStream: DataStream[DynamicKeyEvent] = uuidStream
        .flatMap[DynamicKeyEvent](
      (transaction: UuidTransaction, coll: Collector[DynamicKeyEvent]) =>
        Manager.keyedDefinitions(transaction).foreach { key =>
          val (operationName, operationInput, operation) = Manager.keyedOperations(key)

          // extract only values needed for feature calculation from the payload
          val requiredPayload = operationInput.map(fieldName => fieldName -> transaction.payload(fieldName)).toMap

          val keyValue = List((key, transaction.payload(key)))
          coll.collect(
            // `key take-away` the key is a composition of keyname and value of that key.
            // By doing this we can ensure that the 'following' events will end up at the same node.
            DynamicKeyEvent(transaction.id, operationName, keyValue, transaction.expectedNumberOfKeys, requiredPayload, operationInput, operation)
          )
        }
    )

    // Perform operation at the node where the key belongs.
    val stateStream: DataStream[ResultEvent] = customKeyStream
        .keyBy(_.artificialKey)
        .mapWithState[ResultEvent, Map[String, Value]] {
      case (event: DynamicKeyEvent, maybeState: Option[Map[String, Value]]) =>
        // assign the `program` we want to execute on the 'Value'.
        val operation: (String, Value) => StateF[Double] = event.operation

        // prepare input for the calculation
        import io.github.exploiting.flinks.stateful.operators.magic.ToTuple._
        val operationInputValue: Product = event.operationInput.map(event.payload(_)).toTuple

        // Initialize the interpreter that will be executing our `program`
        val interpreter = FlinkInterpreter(maybeState)

        // Execute the program, return type for now is Double, but could be Any.
        val result: Double = operation(event.operationName, operationInputValue).foldMap(interpreter)

        // Return the result, and assign the new state to this operator.
        (ResultEvent(event.id, event.operationName, result, event.expectedNumberOfKeys), Some(interpreter.state))
    }

    // Join the original event with the picked up state based on UUID.
    val enrichedStream: DataStream[EnrichedTransaction] = uuidStream
        .keyBy(uuidTransaction => uuidTransaction.id)
        .connect(stateStream.keyBy(results => results.id))
        .flatMap(new JoinStreams)

    //now we can score the improved model
    val result = enrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreAdvancedFlyingCarpet(event))
    )

    result
  }

  def waitForResults(event: TransactionEvent): Long =
    Manager.keyedDefinitions(event).length

}

class JoinStreams extends RichCoFlatMapFunction[UuidTransaction, ResultEvent, EnrichedTransaction] {
  import scala.collection.JavaConverters._

  private var resultEvents: MapState[String, Any] = _
  private var enrichedEvent: ListState[EnrichedTransaction] = _

  private def resultEventsAsScalaMap: Predef.Map[String, Any] = Option(resultEvents.entries()).fold(Predef.Map.empty[String, Any])(_.iterator().asScala.toList.map(entry => entry.getKey -> entry.getValue).toMap)
  private def numberOfResultEvents: Int = resultEvents.keys().asScala.size
  private def enrichedEventsAsScalaIterable: Iterable[EnrichedTransaction] = enrichedEvent.get.asScala
  private def numberOfEnrichedEvents: Int = enrichedEvent.get.asScala.size

  override def open(config: Configuration): Unit = {
    super.open(config)
    val resultEventDesc: MapStateDescriptor[String, Any] = new MapStateDescriptor("resultEvents", classOf[String], classOf[Any])
    resultEvents = getRuntimeContext.getMapState(resultEventDesc)

    val uuidDesc: ListStateDescriptor[EnrichedTransaction] = new ListStateDescriptor("enrichedEvent", classOf[EnrichedTransaction])
    enrichedEvent = getRuntimeContext.getListState(uuidDesc)
  }

  /**
    * What do we do, when an UUIDtransaction comes in?
    * First, check if there are already resultevents, (are we complete? => collect) otherwise update state and continue.
    */
  override def flatMap1(value: UuidTransaction, out: Collector[EnrichedTransaction]): Unit = {
    val expectedResults = value.expectedNumberOfKeys

    if (numberOfResultEvents == expectedResults) {
      // We're complete, collect.
      out.collect(EnrichedTransaction(value.id, value.payload, resultEventsAsScalaMap))
      resultEvents.clear()
      enrichedEvent.clear()
    }
    else {
      enrichedEvent.add(EnrichedTransaction(value.id, value.payload, resultEventsAsScalaMap))
    }
  }

  override def flatMap2(value: ResultEvent, out: Collector[EnrichedTransaction]): Unit = {

    if (numberOfEnrichedEvents > 0) {
      val expectedResults = value.expectedAmount

      if (numberOfResultEvents +1 == expectedResults) {
        // append the new element to the results.
        out.collect(enrichedEventsAsScalaIterable.head.copy(state = resultEventsAsScalaMap + (value.key -> value.result)))

        resultEvents.clear()
        enrichedEvent.clear()
      }
      else {
        // we're not complete yet. update state.
        resultEvents.put(value.key, value.result)
      }
    }
    else {
      // we don't have the uuidevent yet.
      resultEvents.put(value.key, value.result)
    }
  }
}
