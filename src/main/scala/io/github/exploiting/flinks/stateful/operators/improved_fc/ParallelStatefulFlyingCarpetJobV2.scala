package io.github.exploiting.flinks.stateful.operators.improved_fc

import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import io.github.exploiting.flinks.stateful.operators.model._
import org.apache.flink.api.common.state.{ValueState, ValueStateDescriptor}
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.functions.co.RichCoFlatMapFunction
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment}
import org.apache.flink.streaming.api.scala._
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.flink.util.Collector

import scala.collection.immutable

object ParallelStatefulFlyingCarpetJobV2 {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in (having only the current location and time,
  // we need to retrieve previous location and calculate speed) one result comes out.
  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)
    val uuidStream: DataStream[EnrichedSimpleUuidTransaction] = inputStream.map(simpleTransaction =>
      EnrichedSimpleUuidTransaction(simpleTransaction, 0, 0, java.util.UUID.randomUUID))

    // Store the current time and location in state and retrieve the previous by this customer.
    val enrichedWithSpeedStream: DataStream[EnrichedSimpleUuidTransaction] = uuidStream
        .keyBy(uuidTransaction => uuidTransaction.transaction.customerId)
        .mapWithState[EnrichedSimpleUuidTransaction, CustomerState] {
      (uuidTransaction, maybeState: Option[CustomerState]) =>
        val transaction = uuidTransaction.transaction
        val speed = calculateSpeed(transaction, maybeState)
        val newState = CustomerState(transaction.location, transaction.UTC)
        val transactionWithSpeed = EnrichedSimpleUuidTransaction(transaction, speed, 0, uuidTransaction.uuid)
        (transactionWithSpeed, Some(newState))
    }


    // Store the current card total amount and number of transaction and calculate the average transaction amount
    val enrichedWithAvAmountStream: DataStream[EnrichedSimpleUuidTransaction] = uuidStream
        .keyBy(uuidTransaction => uuidTransaction.transaction.cardId)
        .mapWithState[EnrichedSimpleUuidTransaction, CardState] {
      (uuidTransaction, maybeState: Option[CardState]) =>
        val transaction = uuidTransaction.transaction
        val prevState = maybeState.getOrElse(CardState(0, 0))
        val avTransactionAmount = calculateAverageAmount(prevState)
        val newState = CardState(prevState.totalAmount + transaction.amount, prevState.totalNrTransactions + 1)

        val transactionWithAvAmount = EnrichedSimpleUuidTransaction(transaction, 0, avTransactionAmount, uuidTransaction.uuid)
        (transactionWithAvAmount, Some(newState))
    }

    // Join the customerResult and cardResult based on cardId.
    val fullyEnrichedStream = enrichedWithSpeedStream.keyBy(_.uuid)
        .connect(enrichedWithAvAmountStream.keyBy(_.uuid))
        .flatMap(new JoinStreams)

    //now we can score the improved model
    val result = fullyEnrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreFlyingCarpet(event))
    )

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }


  private def calculateAverageAmount(prevState: CardState) = {
    if (prevState.totalNrTransactions > 0) prevState.totalAmount / prevState.totalNrTransactions else 0
  }

  private def calculateSpeed(transaction: SimpleTransaction, maybeState: Option[CustomerState]) = {
    maybeState.fold(0.0) {
      state => FraudRules.deriveSpeed(transaction.location, transaction.UTC, state.prevLocation, state.prevUTC)
    }
  }
}

class JoinStreams extends RichCoFlatMapFunction[EnrichedSimpleUuidTransaction, EnrichedSimpleUuidTransaction, EnrichedSimpleUuidTransaction] {

  private var customerSpeed: ValueState[Double] = _
  private var avAmount: ValueState[Double] = _

  private def customerSpeedIsAlreadyGiven = Option(customerSpeed.value()).isDefined
  private def avgCardTrxAmoundIsAlreadyGiven = Option(avAmount.value()).isDefined

  override def open(config: Configuration): Unit = {
    super.open(config)
    customerSpeed = getRuntimeContext.getState(new ValueStateDescriptor[Double]("customerSpeed", classOf[Double]))
    avAmount = getRuntimeContext.getState(new ValueStateDescriptor[Double]("avgCustomerTransactionAmount", classOf[Double]))
  }

  // This is the incoming enrichedWithSpeedStream
  override def flatMap1(in1: EnrichedSimpleUuidTransaction, collector: Collector[EnrichedSimpleUuidTransaction]): Unit =
    if (avgCardTrxAmoundIsAlreadyGiven) {
      // Aggregate the incoming data with the average trx amount from state and send out the event.
      val fullyEnrichedTransaction = in1.copy(avgCardTransactionAmount = avAmount.value())
      collector.collect(fullyEnrichedTransaction)
      customerSpeed.clear()
      avAmount.clear()
    } else {
      // Store the received customer speed. We'll have to wait for the next event to come in.
      customerSpeed.update(in1.customerSpeed)
    }

  //This is the incoming enrichedWithAvAmountStream
  override def flatMap2(in2: EnrichedSimpleUuidTransaction, collector: Collector[EnrichedSimpleUuidTransaction]): Unit =
    if (customerSpeedIsAlreadyGiven) {
      // Aggregate the data with the customerSpeed from state and send out the event.
      val fullyEnrichedTransaction = in2.copy(customerSpeed = customerSpeed.value())
      collector.collect(fullyEnrichedTransaction)
    } else {
      //Store the received average trx amount. We'll have to wait for the next event to come in.
      avAmount.update(in2.avgCardTransactionAmount)
    }
}