package io.github.exploiting.flinks.stateful.operators.improved_fc

import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import io.github.exploiting.flinks.stateful.operators.model._
import org.apache.flink.api.common.state.{ValueState, ValueStateDescriptor}
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.functions.co.RichCoFlatMapFunction
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment}
import org.apache.flink.streaming.api.scala._
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows
import org.apache.flink.streaming.api.windowing.time.Time
import org.apache.flink.util.Collector

import scala.collection.immutable

object ParallelStatefulFlyingCarpetJobV2 {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in (having only the current location and time,
  // we need to retrieve previous location and calculate speed) one result comes out.
  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)
    val uuidStream: DataStream[EnrichedSimpleUuidTransaction] = inputStream.map(simpleTransaction =>
      EnrichedSimpleUuidTransaction(simpleTransaction, 0, 0, java.util.UUID.randomUUID))

    // Store the current time and location in state and retrieve the previous by this customer.
    val keyedByCustomerStream: DataStream[EnrichedSimpleUuidTransaction] = uuidStream
        .keyBy(transaction => transaction.transaction.customerId)
        .mapWithState[EnrichedSimpleUuidTransaction, CustomerState] {
      case (transaction, maybeState: Option[CustomerState]) =>
        val trx = transaction.transaction
        val newState = CustomerState(trx.location, trx.UTC)
        val speed = maybeState match {
          case None => 0.0
          case Some(state) => FraudRules.deriveSpeed(transaction.location, transaction.UTC, state.prevLocation, state.prevUTC)
        }
        val enriched = EnrichedSimpleUuidTransaction(trx, speed, 0, transaction.id)
        (enriched, Some(newState))
    }


    // Store the current card total amount and number of transaction and calculate the average transaction amount
    val keyedByCardStream: DataStream[EnrichedSimpleUuidTransaction] = uuidStream
        .keyBy(transaction => transaction.transaction.cardId)
        .mapWithState[EnrichedSimpleUuidTransaction, CardState] {
      case (transaction, maybeState: Option[CardState]) =>
        val trx = transaction.transaction
    val keyedByCardStream: DataStream[EnrichedSimpleTransaction] = uuidStream
        .keyBy(uuidTransaction => uuidTransaction.transaction.cardId)
        .mapWithState[EnrichedSimpleTransaction, CardState] {
      case (uuidTransaction, maybeState: Option[CardState]) =>
        val transaction = uuidTransaction.transaction
        val prevState = maybeState.getOrElse(CardState(0, 0))
        val newState = CardState(prevState.totalAmount + transaction.amount, prevState.totalNrTransactions + 1)
        val avTransactionAmount = if (prevState.totalNrTransactions > 0) prevState.totalAmount / prevState.totalNrTransactions else 0

        val enriched = EnrichedSimpleUuidTransaction(trx, 0, avTransactionAmount, transaction.id)
        (enriched, Some(newState))
    }

    // Join the customerResult and cardResult based on cardId.
    val enrichedStream = keyedByCustomerStream.keyBy(_.uuid)
        .connect(keyedByCardStream.keyBy(_.uuid))
        .flatMap(new JoinStreams)

    //now we can score the improved model
    val result = enrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreFlyingCarpet(event))
    )

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }
}

class JoinStreams extends RichCoFlatMapFunction[EnrichedSimpleUuidTransaction, EnrichedSimpleUuidTransaction, EnrichedSimpleUuidTransaction] {

  private var customerSpeed: ValueState[Double] = _
  private var avgCardTransactionAmount: ValueState[Double] = _

  private def customerSpeedIsAlreadyGiven = Option(customerSpeed.value()).isDefined

  private def avgCardTrxAmoundIsAlreadyGiven = Option(avgCardTransactionAmount.value()).isDefined

  override def open(config: Configuration): Unit = {
    super.open(config)
    customerSpeed = getRuntimeContext.getState(new ValueStateDescriptor[Double]("customerSpeed", classOf[Double]))
    avgCardTransactionAmount = getRuntimeContext.getState(new ValueStateDescriptor[Double]("avgCustomerTransactionAmount", classOf[Double]))
  }

  // This is the incoming keyedByCustomerStream
  override def flatMap1(in1: EnrichedSimpleUuidTransaction, collector: Collector[EnrichedSimpleUuidTransaction]): Unit =
    if (avgCardTrxAmoundIsAlreadyGiven) {
      // Aggregate the incoming data with the average trx amount from state and send out the event.
      collector.collect(in1.copy(avgCardTransactionAmount = avgCardTransactionAmount.value()))
    } else {
      // Store the received customer speed. We'll have to wait for the next event to come in.
      customerSpeed.update(in1.customerSpeed)
    }

  //This is the incoming keyedByCardStream
  override def flatMap2(in2: EnrichedSimpleUuidTransaction, collector: Collector[EnrichedSimpleUuidTransaction]): Unit =
    if (customerSpeedIsAlreadyGiven) {
      // Aggregate the data with the customerSpeed from state and send out the event.
      collector.collect(in2.copy(customerSpeed = customerSpeed.value()))
    } else {
      //Store the received average trx amount. We'll have to wait for the next event to come in.
      avgCardTransactionAmount.update(in2.avgCardTransactionAmount)
    }
}