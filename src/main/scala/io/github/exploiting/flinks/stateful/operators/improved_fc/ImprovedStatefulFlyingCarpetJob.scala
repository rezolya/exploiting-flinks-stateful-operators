package io.github.exploiting.flinks.stateful.operators.improved_fc

import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import io.github.exploiting.flinks.stateful.operators.model._
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment}
import org.apache.flink.streaming.api.scala._

import scala.collection.immutable

object ImprovedStatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in (having only the current locatino and time,
  // we need to retrieve previous location and calculate speed) one result comes out.
  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)

    // Store the current time and location in state and retrieve the previous by this customer.
    val keyedByCustomerStream: DataStream[EnrichedSimpleTransaction] = inputStream
      .keyBy(transaction => transaction.customerId)
      .mapWithState[EnrichedSimpleTransaction, CustomerState] {
        case (transaction, maybeState: Option[CustomerState]) =>
          val newState = CustomerState(transaction.location, transaction.UTC)
          val speed = maybeState match {
            case None => 0.0
            case Some(state) => FraudRules.deriveSpeed(transaction.location, transaction.UTC, state.prevLocation, state.prevUTC)
          }
          val enriched = EnrichedSimpleTransaction(transaction, speed, 0)
          (enriched, Some(newState))
      }

    val keyedByCardStream: DataStream[EnrichedSimpleTransaction] = keyedByCustomerStream
      .keyBy(enrichedTransaction => enrichedTransaction.transaction.cardId)
      .mapWithState[EnrichedSimpleTransaction, CardState]{
        case (enrichedTransaction, maybeState: Option[CardState]) =>
        val prevState = maybeState.getOrElse(CardState(0, 0))
        val newState =  CardState(prevState.totalAmount+enrichedTransaction.transaction.amount, prevState.totalNrTransactions+1)
        val avTransactionAmount = if(prevState.totalNrTransactions>0) prevState.totalAmount/prevState.totalNrTransactions else 0

        val enriched = EnrichedSimpleTransaction(enrichedTransaction.transaction, enrichedTransaction.customerSpeed, avTransactionAmount)
        (enriched, Some(newState))
      }

    // Join the customer with all used cards with the card and all transactions,
    // to obtain all amounts of this customer over all cards (we wait 100 millis before discarding the event).
    val result = keyedByCardStream.map(event =>
      ScoringResult(event, FraudRules.scoreFlyingCarpet(event))
    )

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }

  //  /**
  //    * Join the customerResult and cardResult based on cardId.
  //    * @param customers All incoming customers.
  //    * @param cards All cards.
  //    * @param windowSize For how long do we 'wait' for the events to arrive at this operator.
  //    * @return The result stream that has the customer and all its transaction amounts.
  //    */
  //  def joinStreams(customers: DataStream[CustomerResult],
  //                   cards: DataStream[CardResult],
  //                   windowSize: Long) : DataStream[Result] =
  //    customers.join(cards)
  //      .where(_.customer.cardId)
  //      .equalTo(_.card.id)
  //      .window(TumblingEventTimeWindows.of(Time.milliseconds(windowSize)))
  //      .apply { (cust, card) => Result(cust.customer, cust.amount, card.history) }

}


/**
  * History class that is a circular buffer, oldest elements are overwritten when the buffer is full.
  * @param maxSize How many items we want to store.
  * @param buffer Initialize it with a buffer.
  * @tparam A The type we store in this class.
  */
case class History[A](maxSize: Int, buffer: Vector[A] = immutable.Vector.empty[A]) {
  type CircularBuffer = immutable.Vector[A]

  private def addToCircularBuffer(item : A) : CircularBuffer  =
    if(maxSize > 0)
      buffer.drop(buffer.size - maxSize + 1) :+ item
    else
      buffer

  def :+(item: A): History[A] = History(maxSize, addToCircularBuffer(item))
}
