package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.advanced_fc.Program.{get, put, updateWithDefault}
import io.github.exploiting.flinks.stateful.operators.model.{FraudRules, UTCLocation}

/**
  * This is the object providing the description of the business logic, that has to be executed on the input stream.
  * Note: for the sake of simplicity, it is hardcoded. In the real world it should be delivered to each operator
  *       requiring it via a keyed broadcast stream, introduced in Flink 1.6.
  */
object Manager {

  /**
    * List all keys that we need for storage and retrieval.
    * Note: it could depend on the type of event, but at this point we process all events with the same keys
    */
  def definedKeys: List[Key] =
    List(List("customerId"), List("cardId"))

  /**
    * Information that is needed for calculating a feature on the keyed stream
    *
    * @param featureName name of the feature
    * @param requiredInput list of necessary keys from payload
    * @param operation operation to execute
    */
  case class FeatureDefinition(featureName: String, requiredInput: List[String], operation: (String, Value) => StateF[Double])

  /**
    * Information that is needed for calculating features for the keyed stream.
    * Note: in a real world multiple features could be calculated per key
    *
    * @return a list describing the operatinos that have to be executed on that key
    */
  def featuresForKey(key: Key): FeatureDefinition = key match {
    case List("customerId") => FeatureDefinition("utcLocation", List("UTC", "location"), speedDerivation(_, _))
    case List("cardId") => FeatureDefinition("averageAmount", List("amount"), averageAmount(_, _))
  }

  /**
    * @param key   the key under which the value is saved
    * @param value the value is of type UTCLocation, (Long, (double, double))
    * @return The free program that we can interpret in the operator.
    */
  def speedDerivation(key: String, value: Value): StateF[Double] = {
    val castValue = value.asInstanceOf[UTCLocation]
    for {
      maybeValue <- get[UTCLocation](key)
      _ <- put[Value](key, castValue)
    } yield {
      val storedValue = maybeValue.getOrElse(castValue)
      FraudRules.deriveSpeed(castValue._2, castValue._1, storedValue._2, storedValue._1)
    }
  }

  def averageAmount(key: String, value: Value): StateF[Double] = {
    val castValue = value.asInstanceOf[Tuple1[Double]]
    val default = (0, castValue._1)
    for {
      maybeState <- get[(Int, Double)](key)
      _ <- updateWithDefault[(Int, Double)](key, hist => (hist._1 + 1, hist._2 + castValue._1), default)
    } yield {
      val answer = maybeState.getOrElse(default)
      if (answer._1 > 0) answer._2 / answer._1 else 0
    }
  }
}
