package io.github.exploiting.flinks.stateful.operators.advanced_fc

import io.github.exploiting.flinks.stateful.operators.advanced_fc.Program.{get, put, updateWithDefault}
import io.github.exploiting.flinks.stateful.operators.model.{FraudRules, SimpleTransaction, TransactionEvent, UTCLocation}

object Manager {

  // List all keys that we need for storage and retrieval.
  def keyedDefinitions(eventType: TransactionEvent): List[Key] = eventType match {
    case _: SimpleTransaction => List("customerId", "cardId")
    case _: UuidTransaction => List("customerId", "cardId")
    case _ => List.empty
  }
  def keyedOperations(key: Key): (List[Key], (List[(Key, Value)], Value) => StateF[Double]) = key match {
    case "customerId" => (List("UTC", "location"), speedDerivation(_, _))
    case "cardId" => (List("amount"), averageAmount(_, _))
  }

  /**
    * @param key the key under which the value is saved
    * @param value the value is of type UTCLocation, (Long, (double, double))
    * @return The free program that we can interpret in the operator.
    */
  def speedDerivation(key: List[(Key, Value)], value: Value): StateF[Double] = {
    val castValue = value.asInstanceOf[UTCLocation]
    for {
      maybeValue <- get[UTCLocation](key)
      _ <- put[Value](key, castValue)
    } yield {
      val storedValue = maybeValue.getOrElse(castValue)
      FraudRules.deriveSpeed(castValue._2, castValue._1, storedValue._2, storedValue._1)
    }
  }

  def averageAmount(key: List[(Key, Value)], value: Value): StateF[Double] = {
    val castValue = value.asInstanceOf[Tuple1[Double]]
    val default = (0,castValue._1)
    for {
      maybeState <- get[(Int, Double)](key)
      _ <- updateWithDefault[(Int, Double)](key, hist => (hist._1 + 1, hist._2 + castValue._1), default)
    } yield {
      val answer = maybeState.getOrElse(default)
      if (answer._1 > 0) answer._2 / answer._1 else 0
    }
  }
}
