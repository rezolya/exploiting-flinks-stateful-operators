package io.github.exploiting.flinks.stateful.operators.stateful_fc

import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment, _}

import scala.collection.immutable

object StatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in (having only the current locatino and time,
  // we need to retrieve previous location and calculate speed) one result comes out.
  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)

    // Store the current time and location in state and retrieve the previous by this customer.
    val enrichedCustomerStream: DataStream[EnrichedSimpleTransaction] = inputStream
        .keyBy(transaction => transaction.customerId)
        .mapWithState[EnrichedSimpleTransaction, CustomerState] {
      (transaction, maybeState: Option[CustomerState]) => {
        val speed = calculateSpeed(transaction, maybeState)
        val newState: CustomerState = CustomerState(transaction.location, transaction.UTC)

        val enrichedTransaction = EnrichedSimpleTransaction(transaction, speed)
        (enrichedTransaction, Some(newState))
      }
    }

    // Score the prepared event
    val result = enrichedCustomerStream.map(event =>
      ScoringResult(event, FraudRules.scoreFlyingCarpet(event))
    )

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }

  private def calculateSpeed(transaction: SimpleTransaction, maybeState: Option[CustomerState]) = {
    maybeState.fold(0.0) {
      state => FraudRules.deriveSpeed(transaction.location, transaction.UTC, state.prevLocation, state.prevUTC)
    }
  }
}
