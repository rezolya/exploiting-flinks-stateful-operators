package io.github.exploiting.flinks.stateful.operators

import io.github.exploiting.flinks.stateful.operators.model.{Card, Customer, SimpleTransaction}
import org.apache.flink.streaming.api.functions.source.SourceFunction
import org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext

import scala.util.Random
import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.stateless_fc.StatelessTransaction

object SourceData {
  val Names: Array[String] = Array("tom", "jerry", "alice", "bob", "john", "grace")
  val CardId: Array[Int] = (1 to 10).toArray
}

class ThrottlingSource[A](iterator: Iterator[A], rate: Int) extends /*Parallel*/SourceFunction[A] {
  private[this] val rnd = new Random(hashCode())
  private final val Millis = 1000
  var running = true

  override def run(ctx: SourceContext[A]): Unit = {
    while (running) {
      ctx.getCheckpointLock.synchronized {
        ctx.collect(iterator.next())
      }
      Thread.sleep(Millis/rate)
    }
  }

  override def cancel(): Unit = {
    running = false
  }
}


class SimpleTransactionSource extends Iterator[SimpleTransaction] with Serializable {
  private[this] val custSource = new CustomerSource
  private[this] val cardSource = new CardSource
  val transactionLimit = 250
  private[this] val rnd = new Random(hashCode())

  override def hasNext: Boolean = true
  override def next: SimpleTransaction = {
    SimpleTransaction(custSource.next.id, cardSource.next.id, rnd.nextLocation(), custSource.nextUTC, rnd.nextDouble())
  }
}

class StatelessTransactionSource extends Iterator[StatelessTransaction] with Serializable {
  private[this] val simpleTransactionSource = new SimpleTransactionSource
  private[this] val rnd = new Random(hashCode())
  val historySize = 25
  override def hasNext: Boolean = true

  override def next: StatelessTransaction = {
    val simpleTransaction = simpleTransactionSource.next
    StatelessTransaction(simpleTransaction.customerId,
      simpleTransaction.cardId,
      rnd.nextDouble()*simpleTransactionSource.transactionLimit,
      rnd.nextDouble()*2000
    )
  }
}


class CustomerSource extends Iterator[Customer] with Serializable {
  private[this] val rnd = new Random(hashCode())
  private[this] var prevUTC = System.currentTimeMillis() - 1000*3600*24*100 //100 days ago...

  override def hasNext: Boolean = true

  override def next: Customer = {
    Customer(SourceData.Names(rnd.nextInt(SourceData.Names.length)), SourceData.CardId(rnd.nextInt(SourceData.CardId.length)))
  }

  //TODO update prevUTC per customer
  def nextUTC: Long = {
    val newUtc = rnd.nextUTC(prevUTC)
    prevUTC = newUtc
    newUtc
  }
}

class CardSource extends Iterator[Card] with Serializable {
  private[this] val rnd = new Random(hashCode())
  override def hasNext: Boolean = true
  override def next: Card = {
    Card(SourceData.CardId(rnd.nextInt(SourceData.CardId.length)))
  }
}
