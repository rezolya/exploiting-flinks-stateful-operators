package io.github.exploiting.flinks.stateful.operators

import io.github.exploiting.flinks.stateful.operators.model.{Card, Customer, SimpleTransaction}
import org.apache.flink.streaming.api.functions.source.SourceFunction
import org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext

import scala.util.Random

object SourceData {
  val Names = Array("tom", "jerry", "alice", "bob", "john", "grace")
  val CardId = (1 to 10).toArray
}

class ThrottlingSource[A](iterator: Iterator[A], rate: Int) extends /*Parallel*/SourceFunction[A] {
  private[this] val rnd = new Random(hashCode())
  private final val Millis = 1000
  var running = true

  override def run(ctx: SourceContext[A]): Unit = {
    while (running) {
      ctx.getCheckpointLock.synchronized {
        ctx.collect(iterator.next())
      }
      Thread.sleep(Millis/rate)
    }
  }

  override def cancel(): Unit = {
    running = false
  }
}


class SimpleTransactionSource extends Iterator[SimpleTransaction] with Serializable {
  private[this] val custSource = new CustomerSource
  private[this] val cardSource = new CardSource
  val transactionLimit = 250
  private[this] val rnd = new Random(hashCode())
  def hasNext: Boolean = true
  def next: SimpleTransaction = {
    SimpleTransaction(custSource.next.id, cardSource.next.id, rnd.nextInt(transactionLimit))
  }
}


class CustomerSource extends Iterator[Customer] with Serializable {
  private[this] val rnd = new Random(hashCode())
  def hasNext: Boolean = true
  def next: Customer = {
    Customer(SourceData.Names(rnd.nextInt(SourceData.Names.length)), SourceData.CardId(rnd.nextInt(SourceData.CardId.length)))
  }
}

class CardSource extends Iterator[Card] with Serializable {
  private[this] val rnd = new Random(hashCode())
  def hasNext: Boolean = true
  def next: Card = {
    Card(SourceData.CardId(rnd.nextInt(SourceData.CardId.length)))
  }
}





