package io.github.exploiting.flinks.stateful.operators

import io.github.exploiting.flinks.stateful.operators.model._
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala._

import scala.collection.immutable

object CompleteEventWithOneKey {

  // The source, at a rate of 10 elements/sec.
  val fullTransactionSource = new ThrottlingSource[StatelessTransaction](new StatelessTransactionSource, 10)

  // One event comes in (with all historical data) one result comes out.
  def main(args: Array[String]): Unit = {

    // set up the streaming execution environment
    val env = StreamExecutionEnvironment.getExecutionEnvironment

    // Use ingestion time, since our events don't have eventtime?
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[StatelessTransaction] = env.addSource(fullTransactionSource)

    val keyedCustomerStream: DataStream[Result] = inputStream
      .map(event =>
        Result(event, FraudRules.scoreFlyingCarpet(event))
      )

    keyedCustomerStream.print()

    // execute program
    env.execute("Flink Simple Fraudulent transaction")
  }
}


object SimpleEventWithMultipleKeys {

  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in, two keys, historical data will be collected and retrievd, one result comes out.
  def main(args: Array[String]): Unit = {

    // The amount of values to be stored in the stateful operator.
    val nrOfHistory = 1

    // set up the streaming execution environment
    val env = StreamExecutionEnvironment.getExecutionEnvironment

    // Use ingestion time, since our events don't have eventtime?
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)

    type LastLocation = (Long, (Double, Double))
    // Store the card that the customer uses in state and retrieve all used cards by this customer.
    val keyedCustomerStream: DataStream[CustomerResult] = inputStream
      .keyBy(event => event.customerId)
      .mapWithState[CustomerResult, LastLocation] {
      case (event, maybeState: Option[LastLocation]) =>
        val newState: LastLocation = maybeState match {
          case Some(location) => (event.UTC, event.location)
          case None => (event.UTC, event.location)
        }
        val speed = FraudRules.deriveSpeed(event.location, event.UTC, maybeState)
        (CustomerResult(event.customerId, event.cardId, event.amount, speed), Some(newState))
    }

    // Join the customer with all used cards with the card and all transactions,
    // to obtain all amounts of this customer over all cards (we wait 100 millis before discarding the event).
    val result = keyedCustomerStream.map(event =>
      ResultStateful(event, FraudRules.scoreFlyingCarpet(event))
    )

    result.print()

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }

//  /**
//    * Join the customerResult and cardResult based on cardId.
//    * @param customers All incoming customers.
//    * @param cards All cards.
//    * @param windowSize For how long do we 'wait' for the events to arrive at this operator.
//    * @return The result stream that has the customer and all its transaction amounts.
//    */
//  def joinStreams(customers: DataStream[CustomerResult],
//                   cards: DataStream[CardResult],
//                   windowSize: Long) : DataStream[Result] =
//    customers.join(cards)
//      .where(_.customer.cardId)
//      .equalTo(_.card.id)
//      .window(TumblingEventTimeWindows.of(Time.milliseconds(windowSize)))
//      .apply { (cust, card) => Result(cust.customer, cust.amount, card.history) }

}


/**
  * History class that is a circular buffer, oldest elements are overwritten when the buffer is full.
  * @param maxSize How many items we want to store.
  * @param buffer Initialize it with a buffer.
  * @tparam A The type we store in this class.
  */
case class History[A](maxSize: Int, buffer: Vector[A] = immutable.Vector.empty[A]) {
  type CircularBuffer = immutable.Vector[A]

  private def addToCircularBuffer(item : A) : CircularBuffer  =
    if(maxSize > 0)
      buffer.drop(buffer.size - maxSize + 1) :+ item
    else
      buffer

  def :+(item: A): History[A] = History(maxSize, addToCircularBuffer(item))
}
