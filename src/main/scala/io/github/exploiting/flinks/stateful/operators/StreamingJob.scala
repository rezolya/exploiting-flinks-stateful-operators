package io.github.exploiting.flinks.stateful.operators

import io.github.exploiting.flinks.stateful.operators.model._
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala._
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows
import org.apache.flink.streaming.api.windowing.time.Time

import scala.collection.immutable

case class CustomerResult(customer: Customer, transaction: Int, history: History[Card])
case class CardResult(card: Card, history: History[Int])
case class Result(customer: Customer, transaction: Int, transactionHistory: History[Int])


object CompleteEventWithOneKey {

  // The source, at a rate of 10 elements/sec.
  val fullTransactionSource = new ThrottlingSource[FullTransaction](new FullTransactionSource, 10)

  // One event comes in (with all historical data) one result comes out.
  def main(args: Array[String]): Unit = {

    // set up the streaming execution environment
    val env = StreamExecutionEnvironment.getExecutionEnvironment

    // Use ingestion time, since our events don't have eventtime?
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[FullTransaction] = env.addSource(fullTransactionSource)

    val keyedCustomerStream: DataStream[Result] = inputStream
      .keyBy(event => event.customerId)
      .map(event =>
        Result(Customer(event.customerId, event.cardId), event.amount, event.amounts)
      )

    // Drop all transactions that are within 2 times standard deviation (no fraud).
    val fraudulentStream = keyedCustomerStream.filter { res =>
        FraudRules
          .inputIsFraudulent[Int](FraudRules.twiceStdDevPredicate(res.transactionHistory.buffer))(res.transaction)
      }

    fraudulentStream.print()

    // execute program
    env.execute("Flink Simple Fraudulent transaction")
  }

  /**
    * Join the customerResult and cardResult based on cardId.
    * @param customers All incoming customers.
    * @param cards All cards.
    * @param windowSize For how long do we 'wait' for the events to arrive at this operator.
    * @return The result stream that has the customer and all its transaction amounts.
    */
  def joinStreams(customers: DataStream[CustomerResult],
                   cards: DataStream[CardResult],
                   windowSize: Long) : DataStream[Result] =
    customers.join(cards)
      .where(_.customer.cardId)
      .equalTo(_.card.id)
      .window(TumblingEventTimeWindows.of(Time.milliseconds(windowSize)))
      .apply { (cust, card) => Result(cust.customer, cust.transaction, card.history) }

}


object SimpleEventWithMultipleKeys {


  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in, two keys, historical data will be collected and retrievd, one result comes out.
  def main(args: Array[String]): Unit = {

    // The amount of values to be stored in the stateful operator.
    val nrOfHistory = 20

    // set up the streaming execution environment
    val env = StreamExecutionEnvironment.getExecutionEnvironment

    // Use ingestion time, since our events don't have eventtime?
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)

    // Store the card that the customer uses in state and retrieve all used cards by this customer.
    val keyedCustomerStream: DataStream[CustomerResult] = inputStream
      .keyBy(event => event.customerId)
      .mapWithState[CustomerResult, History[Card]] {
      case (event, maybeState: Option[History[Card]]) =>
        val newState: History[Card] = maybeState match {
          case Some(list) => list :+ Card(event.cardId)
          case None => History[Card](nrOfHistory) :+ Card(event.cardId)
        }
        (CustomerResult(Customer(event.customerId, event.cardId), event.amount, newState), Some(newState))
    }

    // Store the transaction amount that this card was used for, and return all transactionamounts of this card.
    val keyedCardStream: DataStream[CardResult] = inputStream
      .keyBy(event => event.cardId)
      .mapWithState[CardResult, History[Int]] {
      case (event, maybeState: Option[History[Int]]) =>
        val newState: History[Int] = maybeState match {
          case Some(list) => list :+ event.amount
          case None => History[Int](nrOfHistory) :+ event.amount
        }
        (CardResult(Card(event.cardId), newState), Some(newState))
    }

    // Join the customer with all used cards with the card and all transactions,
    // to obtain all amounts of this customer over all cards (we wait 100 millis before discarding the event).
    val result = joinStreams(keyedCustomerStream, keyedCardStream, 100)

    result.print()

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }

  /**
    * Join the customerResult and cardResult based on cardId.
    * @param customers All incoming customers.
    * @param cards All cards.
    * @param windowSize For how long do we 'wait' for the events to arrive at this operator.
    * @return The result stream that has the customer and all its transaction amounts.
    */
  def joinStreams(customers: DataStream[CustomerResult],
                   cards: DataStream[CardResult],
                   windowSize: Long) : DataStream[Result] =
    customers.join(cards)
      .where(_.customer.cardId)
      .equalTo(_.card.id)
      .window(TumblingEventTimeWindows.of(Time.milliseconds(windowSize)))
      .apply { (cust, card) => Result(cust.customer, cust.transaction, card.history) }

}


/**
  * History class that is a circular buffer, oldest elements are overwritten when the buffer is full.
  * @param maxSize How many items we want to store.
  * @param buffer Initialize it with a buffer.
  * @tparam A The type we store in this class.
  */
case class History[A](maxSize: Int, buffer: Vector[A] = immutable.Vector.empty[A]) {
  type CircularBuffer = immutable.Vector[A]

  private def addToCircularBuffer(item : A) : CircularBuffer  =
    if(maxSize > 0)
      buffer.drop(buffer.size - maxSize + 1) :+ item
    else
      buffer

  def :+(item: A): History[A] = History(maxSize, addToCircularBuffer(item))
}
