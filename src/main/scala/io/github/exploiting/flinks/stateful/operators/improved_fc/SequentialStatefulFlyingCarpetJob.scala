package io.github.exploiting.flinks.stateful.operators.improved_fc

import io.github.exploiting.flinks.stateful.operators.model._
import io.github.exploiting.flinks.stateful.operators.{SimpleTransactionSource, ThrottlingSource}
import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.scala.{DataStream, StreamExecutionEnvironment, _}

object SequentialStatefulFlyingCarpetJob {
  // The source, at a rate of 10 elements/sec.
  val simpleTransactionSource = new ThrottlingSource[SimpleTransaction](new SimpleTransactionSource, 10)

  // One event comes in (having only the current locatino and time,
  // we need to retrieve previous location and calculate speed) one result comes out.
  def main(args: Array[String]): Unit = {
    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)

    val inputStream: DataStream[SimpleTransaction] = env.addSource(simpleTransactionSource)

    // Store the current time and location in state and retrieve the previous by this customer.
    val enrichedWithSpeedStream: DataStream[EnrichedSimpleTransaction] = inputStream
        .keyBy(transaction => transaction.customerId)
        .mapWithState[EnrichedSimpleTransaction, CustomerState] {
      case (transaction, maybeState: Option[CustomerState]) =>
        val speed = calculateSpeed(transaction, maybeState)
        val newState = CustomerState(transaction.location, transaction.UTC)
        val transactionWithSpeed = EnrichedSimpleTransaction(transaction, speed, 0)
        (transactionWithSpeed, Some(newState))
    }

    // Store the current card total amount and number of transaction and calculate the average transaction amount
    val fullyEnrichedStream: DataStream[EnrichedSimpleTransaction] = enrichedWithSpeedStream
        .keyBy(enrichedTransaction => enrichedTransaction.transaction.cardId)
        .mapWithState[EnrichedSimpleTransaction, CardState] {
      case (enrichedTransaction, maybeState: Option[CardState]) =>
        val prevState = maybeState.getOrElse(CardState(0, 0))
        val avTransactionAmount = calculateAverageAmount(prevState)
        val newState = CardState(prevState.totalAmount + enrichedTransaction.transaction.amount, prevState.totalNrTransactions + 1)

        val transactionWithAvAmount = EnrichedSimpleTransaction(enrichedTransaction.transaction, enrichedTransaction.customerSpeed, avTransactionAmount)
        (transactionWithAvAmount, Some(newState))
    }

    //now we can score the improved model
    val result = fullyEnrichedStream.map(event =>
      ScoringResult(event, FraudRules.scoreImprovedFlyingCarpet(event))
    )

    result.print()

    println(env.getExecutionPlan)

    // execute program
    env.execute("Flink Multi-keyed Fraudulent Transaction")
  }

  private def calculateAverageAmount(prevState: CardState) = {
    if (prevState.totalNrTransactions > 0) prevState.totalAmount / prevState.totalNrTransactions else 0
  }

  private def calculateSpeed(transaction: SimpleTransaction, maybeState: Option[CustomerState]) = {
    maybeState.fold(0.0) {
      state => FraudRules.deriveSpeed(transaction.location, transaction.UTC, state.prevLocation, state.prevUTC)
    }
  }
}